# handlers/responses.py
from aiogram import types, F
from aiogram.types import CallbackQuery
from handlers.questions import (
    ask_fatigue,
    ask_motivation,
    ask_psi_noise,
    ask_sleep,
    ask_socio_signal,
    ask_inner_voice,
    ask_cipher,
)

from utils.state import user_state
import random


async def process_energy(callback: CallbackQuery):
    level = callback.data.split("_")[1]
    user_id = callback.from_user.id
    user_state.setdefault(user_id, {}).setdefault("current", {})["energy"] = level

    responses = {
        "1": [
            "Энергорезерв критически низкий. Дальнейшее движение рискованно.",
            "Отмечен энергетический провал. Рекомендуется укрытие.",
            "Показатель на грани. Вероятны сбои координации и восприятия.",
            "Критическое снижение мощности. Рекомендуется прекратить активность.",
            "Энергосистема нестабильна. Функционирование под угрозой.",
            "Выход на нулевой уровень. Требуется немедленное восполнение.",
        ],
        "2": [
            "Энергия нестабильна. Рекомендуется снизить активность.",
            "Запас ниже безопасного уровня. Не геройствуй.",
            "Поддерживается рабочий минимум. Требуется контроль нагрузки.",
            "Ресурсы снижаются. Переход в экономичный режим.",
            "Обнаружен износ источника энергии. Продолжай с осторожностью.",
            "Запас допустим, но нестабилен. Не допускай перегрузок.",
        ],
        "3": [
            "Показатели в норме. Боеспособность подтверждена.",
            "Энергетический фон стабильный. Маршрут доступен.",
            "Заряд достаточен для выполнения задач. Препятствий нет.",
            "Ресурсы в рабочем диапазоне. Продолжай движение.",
            "Уровень энергии удовлетворителен. Риски минимальны.",
            "Динамика нормальная. Системы функционируют штатно.",
        ],
        "4": [
            "Регистрируется высокий заряд. Действие разрешено.",
            "Энергетические ресурсы на максимуме. Готов к выбросу.",
            "Резерв стабилен. Пропуск открыт.",
            "Энергопрофиль в идеале. Все системы готовы.",
            "Пиковое значение зафиксировано. Режим расширенного действия активен.",
            "Полный резерв. Возможна высокая нагрузка.",
        ],
    }

    await callback.message.answer(random.choice(responses[level]))
    await callback.answer()
    await ask_fatigue(callback)


async def process_fatigue(callback: CallbackQuery):
    level = callback.data.split("_")[1]
    user_id = callback.from_user.id
    user_state.setdefault(user_id, {}).setdefault("current", {})["fatigue"] = level

    responses = {
        "1": [
            "Физическая нагрузка в пределах нормы. Состояние стабильное.",
            "Износ мышечной системы минимален. Режим действия допустим.",
            "Биомеханические показатели соответствуют стандарту.",
            "Тело функционирует без отклонений. Риски отсутствуют.",
            "Соматические сбои не зафиксированы. Движение разрешено.",
            "Восстановление завершено. Перегрузка не обнаружена.",
        ],
        "2": [
            "Обнаружены признаки утомления. Не критично.",
            "Нагрузка превышает рекомендованную. Темп следует снизить.",
            "Мышечный тонус снижен. Возможны временные сбои.",
            "Состояние близко к порогу износа. Внимание к опорно-двигательной системе.",
            "Наблюдается утомление. Продолжай с контролем.",
            "Износ нарастает. Не рекомендуется ускорение.",
        ],
        "3": [
            "Тревожные маркеры: перегрузка и микротравмы. Режим экстренного восстановления.",
            "Система сообщает о физическом истощении. Приоритет — отдых.",
            "Износ тела критический. Необходима регенерация.",
            "Физический ресурс исчерпан. Дальнейшее движение опасно.",
            "Зафиксированы сбои в координации и тонусе. Рекомендуется укрытие.",
            "Моторика нарушена. Действие ограничено по всем осям.",
        ],
    }

    await callback.message.answer(random.choice(responses[level]))
    await callback.answer()
    await ask_motivation(callback)


async def process_motivation(callback: CallbackQuery):
    level = callback.data.split("_")[1]
    user_id = callback.from_user.id
    user_state.setdefault(user_id, {}).setdefault("current", {})["motivation"] = level

    responses = {
        "1": [
            "Психоэнергетический импульс высок. Движение вперёд допустимо.",
            "Внутренний вектор направлен на действие. Фиксирую активность.",
            "Мотивационный уровень стабилен. Продолжай маршрут.",
            "Инициатива зафиксирована. Возможности расширены.",
            "Система зафиксировала импульс стремления. Путь открыт.",
            "Регистрируется готовность к взаимодействию с Зоной. Принято.",
        ],
        "2": [
            "Движение поддерживается остаточным импульсом. Продолжай с наблюдением.",
            "Мотивационный пульс на среднем уровне. Возможна апатия.",
            "Инерция движения зафиксирована. Настроение нестабильно.",
            "Импульс к действию ослаблен. Требуется внешняя поддержка.",
            "Уровень инициативы понижен. Рекомендуется щадящий режим.",
            "Действие осуществляется без чёткого вектора. Контроль снижен.",
        ],
        "3": [
            "Импульс подавлен. Движение осуществляется через усилие.",
            "Отсутствие мотивации зафиксировано. Вероятна стагнация.",
            "Психическая динамика угасает. Пауза рекомендована.",
            "Система выявила критически низкий уровень внутреннего импульса.",
            "Дальнейшее продвижение может вызвать сопротивление среды.",
            "Регистрируется эмоциональный спад. Рекомендуется отдых.",
        ],
    }

    await callback.message.answer(random.choice(responses[level]))
    await callback.answer()
    await ask_psi_noise(callback)


async def process_psi_noise(callback: CallbackQuery):
    level = callback.data.split("_")[1]
    user_id = callback.from_user.id
    user_state.setdefault(user_id, {}).setdefault("current", {})["psi_noise"] = level

    responses = {
        "1": [
            "Пси-фон чистый. Наблюдение не фиксирует внутренних помех.",
            "Внутреннее пространство стабильно. Канал восприятия свободен.",
            "Психоэмоциональный шум отсутствует. Возможность навигации повышена.",
            "Фоновые колебания в пределах допустимого. Система уравновешена.",
            "Ментальный фильтр работает штатно. Нарушений не зафиксировано.",
            "Психическая активность в пределах нормы. Доступ к Зоне безопасен.",
        ],
        "2": [
            "Регистрируется слабый внутренний шум. Не мешает выполнению задач.",
            "Фоновый пси-сигнал обнаружен. Продолжай с повышенной внимательностью.",
            "Внутренние колебания умеренны. Нестабильность незначительна.",
            "Показатели пси-фона на грани допустимого. Фильтрация требуется.",
            "Пси-сигнал нестабилен. Возможны искажения восприятия.",
            "Ментальный шум фоновый. Эффективность снижена незначительно.",
        ],
        "3": [
            "Пси-шторм активен. Зафиксирована критическая нестабильность.",
            "Психосфера перегружена. Дальнейшие действия под угрозой.",
            "Сильный внутренний шум. Возможна потеря ориентировки.",
            "Нарушена когнитивная фильтрация. Шанс ошибки возрастает.",
            "Резкие ментальные колебания. Рекомендуется укрытие.",
            "Показатели тревожны. Пси-нагрузка требует разгрузки.",
        ],
    }

    await callback.message.answer(random.choice(responses[level]))
    await callback.answer()
    await ask_sleep(callback)


async def process_sleep(callback: CallbackQuery):
    level = callback.data.split("_")[1]
    user_id = callback.from_user.id
    user_state.setdefault(user_id, {}).setdefault("current", {})["sleep"] = level

    responses = {
        "1": [
            "Регистрируется полноценный восстановительный сон. Биосистема стабилизирована.",
            "Сон глубокий. Энергетические потери компенсированы.",
            "Показатели сна соответствуют норме. Движение разрешено.",
            "Ритмы восстановлены. Угроза истощения снята.",
            "Фаза сна пройдена корректно. Биологическая система сбалансирована.",
            "Физическая и когнитивная перезагрузка завершена. Продолжай маршрут.",
        ],
        "2": [
            "Регистрируются прерывания сна. Эффективность отдыха снижена.",
            "Сон фрагментирован. Возможны остаточные искажения реакции.",
            "Ночное восстановление не завершено. Внимательность требуется.",
            "Были сигналы активности во сне. Возможен ментальный фон.",
            "Показатели сна нестабильны. Перезагрузка частичная.",
            "Сон неполный. Контроль состояния усилен.",
        ],
        "3": [
            "Сон тревожный. Биоритмы нарушены.",
            "Фиксируются ночные всплески тревожности. Возможна уязвимость.",
            "Регенерация прервана. Уровень готовности снижен.",
            "Показатели сна нарушены. Требуется внимание к психоэмоциональному фону.",
            "Отмечены скачки напряжения во сне. Перегруз возможен.",
            "Режим сна нестабилен. Рекомендуется коррекция режима.",
        ],
        "4": [
            "Сон не зафиксирован. Состояние истощения критично.",
            "Показатели сна нулевые. Приоритет — восстановление.",
            "Отсутствие сна угрожает когнитивной стабильности.",
            "Зафиксировано полное нарушение ночного цикла. Действие ограничено.",
            "Не наблюдалась фаза сна. Требуется немедленный отдых.",
            "Цикл сна отсутствует. Перезагрузка невозможна.",
        ],
    }

    await callback.message.answer(random.choice(responses[level]))
    await callback.answer()
    await ask_socio_signal(callback)


async def process_socio(callback: CallbackQuery):
    level = callback.data.split("_")[1]
    user_id = callback.from_user.id
    user_state.setdefault(user_id, {}).setdefault("current", {})["socio"] = level

    responses = {
        "1": [
            "Социальная активность сведена к минимуму. Уровень взаимодействия низкий.",
            "Изоляция подтверждена. Внешние сигналы игнорируются.",
            "Контакт с окружающими прерван. Фокус на внутренние ресурсы.",
            "Отмечена полная отстранённость. Эхо внешнего мира отсутствует.",
            "Сигналы извне заблокированы. Настройка на одиночный режим.",
            "Связь снаружи не зафиксирована. Пользователь в автономии.",
        ],
        "2": [
            "Канал взаимодействия открыт. Возможность контакта подтверждена.",
            "Готовность к приёму и передаче информации подтверждена.",
            "Связь с окружением активна. Система работает в сетевом режиме.",
            "Социальный интерфейс функционирует. Контакт возможен.",
            "Приём внешних сигналов стабилен. Связь установлена.",
            "Наблюдается положительный отклик на взаимодействие. Зафиксировано.",
        ],
        "3": [
            "Запрос на поддержку зафиксирован. Эмоциональный отклик актуален.",
            "Ищется внешний ресурс. Необходимость во взаимодействии повышена.",
            "Требуется контакт. Внутренний потенциал ограничен.",
            "Потребность в обратной связи подтверждена. Канал активен.",
            "Запрос принят. Пользователь ориентирован на поддержку.",
            "Установлен сигнал потребности в объединении. Данные сохранены.",
        ],
        "4": [
            "Перегрузка внешними сигналами. Рекомендуется ограничить контакты.",
            "Социальный канал перенасыщен. Внимание снижено.",
            "Избыточный поток. Защита от вторжения активна.",
            "Восприятие искажено под давлением среды. Перерыв рекомендован.",
            "Система фиксирует раздражение от общения. Возникают сбои.",
            "Наблюдается перенапряжение коммуникационного канала. Требуется изоляция.",
        ],
    }

    await callback.message.answer(random.choice(responses[level]))
    await callback.answer()
    await ask_inner_voice(callback)


async def process_inner_voice(callback: CallbackQuery):
    level = callback.data.split("_")[1]
    user_id = callback.from_user.id
    user_state.setdefault(user_id, {}).setdefault("current", {})["inner_voice"] = level

    responses = {
        "1": [
        "Внутренний голос подтверждает стабильность.",
        "Голос ровный и устойчивый. Зона рядом, но не вмешивается.",
        "Сигнал внутри чистый. Поддержка чувствуется сквозь тишину.",
        "Голос внутри выведен в основной канал. Доверять можно.",
        "Зона соглашается молча. Продолжай путь.",
        "Никаких помех. Внутренний компас на север.",
        "Голос звучит чётко. Поддержка стабильна.",
        "Связь с ядром сознания установлена. Помех не обнаружено.",
        "Внутренний голос работает в штатном режиме. Зона не вмешивается.",
        "Поддержка изнутри. Решения проходят без сопротивления.",
        "Канал чист. Внутренняя структура устойчива.",
        "Психоструктура выровнена. Никаких внутренних возражений.",
        "Фиксирую внутреннее равновесие. Никаких помех.",
        "Пульс и голос совпадают. Движение можно продолжать."
    ],
        "2": [
        "Внутри тишина. Зона, возможно, слушает.",
        "Голос замолк. Иногда молчание — громче сигнала.",
        "Никакой активности. Как будто кто-то выключил приёмник изнутри.",
        "Пауза. Не провал — выжидание.",
        "Система молчит. Не мешай — возможно, идёт настройка.",
        "Молчание — тоже ответ. Зона знает, что ты слышишь.",
        "Сигнал потерян. Только фоновый гул.",
        "Психоканал пуст. В эфире — тишина и треск.",
        "Молчание устойчивое. Система не считает нужным вмешиваться",
        "Внутренний канал молчит. Зона могла отключить приём.",
        "Остались только шум и импульсы. Ни слов, ни смысла.",
        "Шепот был... потом пропал. Ощущается глухая пауза.",
        "Всё заглушено. Как будто кто-то гасит сигнал изнутри.",
        "Белый шум. Даже эхо не задерживается в поле."
    ],
        "3": [
        "Голос внутри токсичен. Воздействие направлено внутрь.",
        "Критика изнутри. Возможно, Зона проверяет твою устойчивость.",
        "Тон голоса режет. Как будто сигнал искажен извне.",
        "Голос давит. Не исключено: Зона вмешалась в поле.",
        "Самокритика зашкаливает. Регистрирую внутреннее разрушение",
        "Механизм саморефлексии перегружен. Внутренний шум усиливается.",
        "Психоканал зашумлён. Слова рвутся, смысл уходит.",
        "Фраза прервана. Зона могла перебить частоту.",
        "Психоканал изнутри нестабилен. Тон агрессивный, рваный.",
        "Внутреннее сообщение несёт вред. Содержание токсично.",
        "Мышление атакует себя. Фиксирую внутреннюю враждебность.",
        "Поток перегружен. Голос внутри говорит резко и сбивчиво.",
        "Тон повышен. Сигнал колеблется, искажается.",
        "Речь агрессивна. Давление изнутри усиливается.",
        "Фон скачет. Каждое слово будто сквозь стекло и ржавчину.",
        "Зафиксирован внутренний конфликт. Уровень самокритики превышен.",
        "Голос дергается, как при выбросе. Требуется фильтрация восприятия.",
        "Отголоски чужого давления. Источник не локализован.",
        "Речь внутри зашумлена. Психоструктура дестабилизирована."
    ],
        "4": [
        "Высмеивает. Возможно, Зона тестирует прочность оболочки.",
        "Голос смеётся — не всегда твой. Будь разборчив.",
        "Внутренний приёмник ловит иронию. Возможно, это не ошибка.",
        "Чужой смех в голове. Спектр не совпадает с твоим.",
        "Сарказм из глубины. Зона дразнит тех, кто ей интересен.",
        "Голос изнутри искажён. Не исключено вмешательство поля.",
        "Наблюдается искажённый тон. Возможно, Зона общается через шутку.",
        "Шутки звучат странно. Слишком точно, чтобы быть случайностью.",
        "Шутка прозвучала не твоим тоном. Похоже, кто-то пробует связь.",
        "Смех внутри. Не твой. Не факт, что дружелюбный.",
        "Сигнал с иронией. Не исключено: Зона включилась в разговор.",
        "Каждая мысль оборачивается смешком. Источник — не локализован.",
        "Смех рвётся сквозь помехи. Кажется, это не ты."
  ],
    }

    await callback.message.answer(random.choice(responses[level]))
    await callback.answer()
    await ask_cipher(callback)
